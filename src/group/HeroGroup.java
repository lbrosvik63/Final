package group;

import java.awt.Graphics;
import java.awt.Image;
import java.awt.Rectangle;
import java.util.ArrayList;
import javax.swing.ImageIcon;

import character.Character;

/*
 * When a hero is killed they remain in the group
 */
public class HeroGroup extends Group {

	private boolean hasKey = false;
	
	private String imageLocation = "/data/character.png";

	private int centerX = 96;
	private int centerY = 96;
	private int row = (centerY - 32)/64; //used to determine position on array[][] map

	private int column = (centerX - 32)/64;
	
	private int speedX = 0;
	private int speedY = 0;
	
	public static Rectangle rect = new Rectangle(0,0,0,0);
	
	
	public HeroGroup(ArrayList<Character> characterList) {
		super(characterList);
		// TODO Auto-generated constructor stub
	}

	public HeroGroup(String char1, String char2, String char3) {
		super(char1, char2, char3);
		// TODO Auto-generated constructor stub
	}

	
	public void update() {

		// Moves Character or Scrolls Background accordingly.
		if (speedX < 0) {
			centerX += speedX;
			column = (centerX - 32)/64;
		} 

		centerX += speedX;
		column = (centerX - 32)/64;
		// Updates Y Position
		centerY += speedY;
		row = (centerY - 32)/64;
		
		rect.setRect(centerX - 32, centerY - 32, 64, 64);
	
	} 
	
	public void render(Graphics g) {
		g.drawImage(getPlayerImage(), centerX -32, centerY -32, null);
		
	}
	
	public Image getPlayerImage(){
		ImageIcon i = new ImageIcon(getClass().getResource(imageLocation));
		return i.getImage();
	}
	
	public int getCenterX() {
		return centerX;
	}

	public void setCenterX(int centerX) {
		this.centerX = centerX;
	}

	public int getCenterY() {
		return centerY;
	}

	public void setCenterY(int centerY) {
		this.centerY = centerY;
	}


	public int getRow() {
		return row;
	}

	public int getColumn() {
		return column;
	}

	public boolean getHasKey() {
		return hasKey;
	}


	public void setHasKey(boolean hasKey) {
		this.hasKey = hasKey;
	}
	

	public void moveDown() {
		//speedY = MOVESPEED;
		centerY += 64;
		row = (centerY - 32)/64;
	}

	public void moveUp() {
		//speedY = -MOVESPEED;
		centerY -= 64;
		row = (centerY - 32)/64;
	}
	
	public void moveRight() {
		//speedX = MOVESPEED;
		centerX += 64;
		column = (centerX - 32)/64;
	}

	public void moveLeft() {
		//speedX = -MOVESPEED;
		centerX -= 64;
		column = (centerX - 32)/64;
	}
	
	
	
	
	
	
	
	
	/*
	 * TODO: If group is dead and you call this method it will throw a divide by 0 Exception
	 * 
	 */
	@Override
	public void recieveAction(Action action){
		
		Character tempCharctr;
		//TODO: TEST
		switch(action.getTarget()){
		case ONE:
			tempCharctr = randomLivingGroupMember();
			tempCharctr.recieveAction(action);
			break;
		case TWO:
			//evenly distributes attackValue to each character
			action.setActionValue(action.getActionValue() /2);
			
			tempCharctr = randomLivingGroupMember();
			tempCharctr.recieveAction(action);
			
			tempCharctr = randomLivingGroupMember();
			tempCharctr.recieveAction(action);
			break;
		case ALL:
			int livingCount = 0;
			//evenly distributes attackValue to each group member
			for(Character character : group){
				if(character.isAlive())
					livingCount ++;
			}
			action.setActionValue(action.getActionValue() / livingCount);
			//Passes on Attack to every 
			for(Character character : group){
				character.recieveAction(action);
			}

		}
		
		
	}
	

	//Returns null if heal. (sends to action to other group)
	//Heal only works on living members of group
	@Override
	public Action determineAction(Action action) {
		switch(action.getHealOrHurt()){
		case HEAL:
			//Will send Action to appropriate Group Members
			//Need way to determine specific members to send to
			Character tempCharctr;
			switch(action.getTarget()){
			case ONE:
				tempCharctr = randomLivingGroupMember();
				tempCharctr.recieveAction(action);
				return null;
			case TWO:
				action.setActionValue(action.getActionValue() /2);
				
				tempCharctr = randomLivingGroupMember();
				tempCharctr.recieveAction(action);
				
				tempCharctr = randomLivingGroupMember();
				tempCharctr.recieveAction(action);
				return null;
			case ALL:
				int livingCount = 0;
				//evenly distributes attackValue to each group member
				for(Character character : group){
					if(character.isAlive())
						livingCount ++;
				}
				action.setActionValue(action.getActionValue() / livingCount);
				//Passes on Attack to every 
				for(Character character : group){
					character.recieveAction(action);
				}
				return null;
			}
		case DAMAGE:
			//Returns Action generated by group member
			return action;
		case SUMMON:
			//Heroes dont use this but would summon additional character to group
			return null;
		}
		return null;
		
	}

	@Override
	public boolean areAlive() {
		for(Character character : group){
			if(character.isAlive())//if 1 character is alive
				return true;
		}
		return false;
	}
	
	
}
